import socket
from flask import Flask, request, jsonify, render_template
from flask_socketio import SocketIO, emit
import threading
import time
from datetime import datetime

app = Flask(__name__)
socketio = SocketIO(app, cors_allowed_origins="*")  # flask-socketio 추가 및 CORS 허용

# === 내부 상태 ===
snack_queue = []
is_processing = False
current_idx = -1
robot_state = "IDLE"  # IDLE, PROCESSING

terminal_logs = []

# === 이벤트 객체로 신호 관리 ===
clear_event = threading.Event()

# 이벤트 발생 시점 latch 역할 (브라우저 폴링 시 놓치지 않도록)
event_latch = {
    "clear": None
}
LATCH_SECONDS = 3.0

processing_lock = threading.Lock()

# === 로봇 소켓 설정 ===
ROBOT_HOST = '192.168.0.6'
ROBOT_PORT = 8888

# ⚠️ RAPID ↔ Flask 구분자: 세미콜론(;) 사용
MSG_DELIM = ";"

robot_socket = None  # 전역 변수: 로봇 소켓 객체


def log(message):
    ts = datetime.now().strftime('%H:%M:%S.%f')[:-3]
    thread_name = threading.current_thread().name
    msg = f"[{ts}] [{thread_name}] {message}"
    print(msg)
    terminal_logs.append(msg)
    if len(terminal_logs) > 200:
        terminal_logs.pop(0)


def set_event_debug(event, name):
    before = event.is_set()
    event.set()
    after = event.is_set()
    event_latch[name.replace("_event", "")] = time.time()
    log(f"[이벤트] {name}.set() 호출 (이전: {before} → 이후: {after}), latch 시간 갱신: {event_latch[name.replace('_event', '')]}")
    log(f"[이벤트] 현재 이벤트 상태: clear_event={clear_event.is_set()}")


def clear_event_debug(event, name):
    before = event.is_set()
    event.clear()
    after = event.is_set()
    event_latch[name.replace("_event", "")] = None
    log(f"[이벤트] {name}.clear() 호출 (이전: {before} → 이후: {after}), latch 시간 제거")
    log(f"[이벤트] 현재 이벤트 상태: clear_event={clear_event.is_set()}")


def send_next_snack(sock):
    """큐에서 다음 스낵을 꺼내 로봇에 전송 (락 안에서 호출되어야 함)"""
    global robot_state, snack_queue, current_idx, robot_socket
    
    if not snack_queue:
        log("[로봇팔] 큐가 비어 모든 작업 완료 → stopping 신호 전송")
        try:
            sock.sendall(f"stopping{MSG_DELIM}".encode())
        except Exception as e:
            log(f"[로봇팔] stopping 신호 전송 실패: {e}")
        robot_state = "IDLE"
        return

    current_snack = snack_queue.pop(0)
    current_idx += 1
    
    log(f"[로봇팔] 전송 준비: {current_snack} (남은 큐: {snack_queue}, index={current_idx})")
    try:
        sock.sendall(f"{current_snack}{MSG_DELIM}".encode())
        log(f"[로봇팔] 스낵 '{current_snack}' 전송 완료. nextall 대기 상태로 전환.")
        robot_state = "PROCESSING"
        socketio.emit('snack_sent', {'snack': current_snack, 'index': current_idx})
    except Exception as e:
        log(f"[로봇팔] 스낵 전송 실패: {e}")
        robot_state = "IDLE" # 에러 발생 시 IDLE로 복귀


def handle_robot_message(msg, sock):
    """RAPID -> Flask 수신 메시지 처리 (상태 머신)"""
    global snack_queue, is_processing, current_idx, robot_state
    
    with processing_lock:
        log(f"[로봇 → Flask] 메시지 수신: {msg} (현재 상태: {robot_state})")

        if msg == "coinpass":
            if robot_state == "IDLE" and is_processing:
                log("[상태머신] coinpass 수신. 첫 스낵 전송 준비.")
                
                # 1. ACK 먼저 전송
                try:
                    sock.sendall(f"ok_coinpass{MSG_DELIM}".encode())
                    log("[상태머신] ok_coinpass 전송 완료.")
                except Exception as e:
                    log(f"[로봇 응답 실패] ok_coinpass 전송 중 에러: {e}")
                    return # ACK 전송 실패 시 더 이상 진행하지 않음

                # 로봇이 ACK를 처리하고 다음 명령을 받을 수 있도록 짧은 지연 추가
                time.sleep(0.1)

                # 2. 첫 스낵 전송
                log("[상태머신] 첫 스낵 전송 시작.")
                send_next_snack(sock)
            else:
                log(f"[상태머신] coinpass 무시됨 (상태: {robot_state}, is_processing: {is_processing})")

        elif msg == "nextall":
            if robot_state == "PROCESSING":
                log("[상태머신] nextall 수신. 다음 스낵 처리.")
                socketio.emit('robot_signal', {'type': 'nextall'})
                send_next_snack(sock)
            else:
                log(f"[상태머신] nextall 무시됨 (상태: {robot_state})")
            try:
                sock.sendall(f"ok_nextall{MSG_DELIM}".encode())
            except Exception as e:
                log(f"[로봇 응답 실패] ok_nextall 전송 중 에러: {e}")

        elif msg == "clear":
            set_event_debug(clear_event, "clear_event")
            snack_queue.clear()
            is_processing = False
            current_idx = -1
            robot_state = "IDLE"
            log("[상태머신] clear 명령 수신 → 모든 상태 초기화")
            socketio.emit('robot_signal', {'type': 'clear'})
            try:
                sock.sendall(f"ok_clear{MSG_DELIM}".encode())
            except Exception as e:
                log(f"[로봇 응답 실패] ok_clear 전송 중 에러: {e}")

        else:
            try:
                sock.sendall(f"unknown_command{MSG_DELIM}".encode())
            except Exception as e:
                log(f"[로봇 응답 실패] unknown_command 전송 중 에러: {e}")
            log(f"[Flask] 알 수 없는 명령: {msg} → unknown_command 응답")
            socketio.emit('robot_signal', {'type': 'unknown', 'raw': msg})


def robot_socket_client():
    """RAPID 서버에 클라이언트로 접속해서, 세미콜론(;) 혹은 개행(\n) 기준으로 메시지 분리"""
    global snack_queue, is_processing, current_idx, robot_socket, robot_state
    while True:
        try:
            log(f"[Flask 소켓클라이언트] RAPID {ROBOT_HOST}:{ROBOT_PORT} 접속 시도...")
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(None)
                s.connect((ROBOT_HOST, ROBOT_PORT))
                robot_socket = s  # 전역 변수에 저장
                
                with processing_lock:
                    robot_state = "IDLE" # 연결 시 IDLE 상태로 초기화
                
                log("[Flask 소켓클라이언트] RAPID 서버에 연결됨!")

                buffer = ""
                while True:
                    try:
                        data = s.recv(4096)
                    except Exception as e:
                        log(f"[Flask 소켓클라이언트 recv 에러] {e}")
                        break

                    if not data:
                        log("[Flask 소켓클라이언트] 데이터 없음, 연결 종료됨")
                        with processing_lock:
                            robot_state = "IDLE"
                            is_processing = False
                        break

                    try:
                        text = data.decode("utf-8", "ignore")
                    except Exception as e:
                        log(f"[디코드 에러] 수신 바이트 디코드 실패: {e}")
                        continue

                    buffer += text
                    # 혹시 로봇이 CRLF/CR 섞어서 보내도 안전하게 LF로 정규화
                    buffer = buffer.replace("\r\n", "\n").replace("\r", "\n")

                    # 세미콜론(;) 또는 개행(\n) 기준으로 앞에서부터 한 줄씩 꺼냄
                    while True:
                        idx_sem = buffer.find(";")
                        idx_nl  = buffer.find("\n")
                        idxs = [i for i in (idx_sem, idx_nl) if i != -1]
                        if not idxs:
                            break  # 아직 한 줄이 안 완성됨 → 다음 recv 대기

                        cut = min(idxs)  # 가장 앞 구분자 위치
                        line = buffer[:cut].strip()
                        buffer = buffer[cut+1:]  # 구분자 제거 후 나머지 보관

                        if line:
                            handle_robot_message(line, s)

        except Exception as e:
            log(f"[Flask 소켓클라이언트 에러] {e}")
            robot_socket = None
            with processing_lock:
                robot_state = "IDLE"
                is_processing = False
            log("3초 후 재접속...")
            time.sleep(3)

# 스낵 별 수정하기.
snack_map = { 
    "": "snack1",
    "": "snack2",
    "": "snack3",
    "": "snack4",
    "": "snack5",
    "": "snack6",
    "": "snack7",
    "": "snack8"
}

# ----------------------------------------
# 기존 HTTP API 부분 (일부 변경 없음)
# ----------------------------------------

@app.route("/")
def index():
    log("[API] / (index.html) 호출됨")
    return render_template("index.html")


@app.route("/start_payment", methods=["POST"])
def start_payment():
    global snack_queue, is_processing, current_idx, robot_state
    data = request.json
    cart = data.get("cart", {})

    with processing_lock:
        if is_processing or robot_state != "IDLE":
            return jsonify({"status": "error", "message": "Robot is busy"}), 400

        snack_queue.clear()
        is_processing = True # 결제가 시작되었고, coinpass를 기다리는 상태
        current_idx = -1 # 첫 스낵이 0번이 되도록 -1로 초기화
        clear_event.clear()
        event_latch["clear"] = None

        log("[API /start_payment] 수신된 장바구니(cart): {cart}")
        for item, count in cart.items():
            signal = snack_map.get(item)
            log(f"  아이템: {item}, 개수: {count}, 매핑 신호: {signal}")
            if signal:
                snack_queue.extend([signal] * count)

        log(f"[API /start_payment] snack_queue 확정: {snack_queue}, is_processing=True로 설정됨")

    return jsonify({"status": "waiting_for_coinpass"})


@app.route("/coinpass", methods=["POST"])
def api_coinpass():
    # 이 API는 디버깅/테스트용으로만 남겨두고, 실제 로봇 신호는 소켓으로 처리
    log(f"[API /coinpass] 테스트용 coinpass 호출됨. 실제 로직은 robot_socket_client에서 처리됩니다.")
    # 실제 로봇 신호를 시뮬레이션하고 싶다면 아래와 같이 handle_robot_message를 직접 호출할 수 있으나,
    # 동시성 문제가 발생할 수 있으므로 주의해야 함.
    # handle_robot_message("coinpass", robot_socket)
    return jsonify({"status": "test_coinpass_received"})


@app.route("/nextall", methods=["POST"])
def api_nextall():
    log("[API /nextall] 테스트용 nextall 호출됨. 사용되지 않음.")
    return jsonify({"status": "next_received_but_ignored"})


@app.route("/clear", methods=["POST"])
def api_clear():
    with processing_lock:
        set_event_debug(clear_event, "clear_event")
        snack_queue.clear()
        is_processing = False
        current_idx = -1
        robot_state = "IDLE"
        log("[API] /clear 호출됨, 상태 초기화")
    return jsonify({"status": "cleared"})


def _is_event_recent(name):
    now = time.time()
    t = event_latch.get(name)
    if t is None:
        return False
    return (now - t) <= LATCH_SECONDS


@app.route("/check_coinpass")
def check_coinpass():
    # coinpass는 이제 상태 머신 내부에서 직접 처리되므로,
    # UI 폴링은 is_processing 상태와 current_idx를 통해 진행 상황을 확인해야 함.
    # 이 엔드포인트는 더 이상 정확한 상태를 반영하지 않을 수 있음.
    status = robot_state != "IDLE"
    log(f"[API] /check_coinpass 호출됨 → robot_state: {robot_state} => 응답: {status}")
    return jsonify({"coinpass": status})


@app.route("/reset_coinpass", methods=["POST"])
def reset_coinpass():
    log("[API] /reset_coinpass 호출됨 (사용되지 않음)")
    return jsonify({"status": "ignored"})


@app.route("/check_nextall")
def check_nextall():
    # 이 엔드포인트는 더 이상 사용되지 않음
    log(f"[API] /check_nextall 호출됨 (사용되지 않음)")
    return jsonify({"nextall": False})


@app.route("/reset_nextall", methods=["POST"])
def reset_nextall():
    log("[API] /reset_nextall 호출됨 (사용되지 않음)")
    return jsonify({"status": "ignored"})


@app.route("/check_processing")
def check_processing():
    current = int(request.args.get("current", -1))
    with processing_lock:
        done = (current < current_idx)
    log(f"[API] /check_processing 호출됨 → current: {current}, current_idx: {current_idx}, done: {done}")
    return jsonify({"done": done})


@app.route("/send_cash_amount", methods=["POST"])
def send_cash_amount():
    global robot_socket
    data = request.json
    amount = data.get("amount")
    log(f"[API] /send_cash_amount 호출됨, 금액: {amount}")

    if not robot_socket:
        log("[Flask] cash_amount 전송 실패: 로봇 소켓 연결 없음")
        return jsonify({"status": "error", "message": "No robot socket connection"}), 500

    try:
        robot_socket.sendall(f"cash:{amount}{MSG_DELIM}".encode())
        log(f"[Flask] 'cash:{amount}' 신호를 로봇에 전송 완료")
        time.sleep(0.5) # 로봇이 cash 메시지를 처리할 시간 확보 (0.05초에서 0.5초로 증가)
        return jsonify({"status": "cash_sent", "amount": amount})
    except Exception as e:
        log(f"[Flask] 'cash:{amount}' 신호 전송 실패: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/send_message', methods=['POST'])
def send_message():
    data = request.get_json()
    message = data.get('message')
    app.logger.info(f"HTML에서 받은 메시지: {message}")
    return jsonify({"status": "ok", "received": message})


@app.route("/send_stopping", methods=["POST"])
def send_stopping():
    global robot_socket
    if robot_socket:
        try:
            robot_socket.sendall(f"stopping{MSG_DELIM}".encode())
            log("[Flask] stopping 신호를 로봇에 전송함")
            return jsonify({"status": "stopping_sent"})
        except Exception as e:
            log(f"[Flask] stopping 신호 전송 실패: {e}")
            return jsonify({"status": "error", "message": str(e)}), 500
    else:
        log("[Flask] stopping 신호 전송 실패: 로봇 소켓 연결 없음")
        return jsonify({"status": "error", "message": "No robot socket connection"}), 500

@app.route('/')
def home():
    return render_template('index.html')


@app.route("/logs")
def get_logs():
    return jsonify(terminal_logs[-50:])


# --------------------------
# 신규 추가 API들
# --------------------------

@app.route("/nextall_done")
def nextall_done():
    current = int(request.args.get("current", -1))
    with processing_lock:
        done = (current < current_idx)
    log(f"[API] /nextall_done 호출 → current: {current}, current_idx: {current_idx}, done: {done}")
    return jsonify({"done": done})


@app.route("/check_clear")
def check_clear():
    status = clear_event.is_set() or _is_event_recent("clear")
    log(f"[API] /check_clear 호출 → clear_event.is_set(): {clear_event.is_set()}, latch: {event_latch.get('clear')} => 응답: {status}")
    return jsonify({"clear": status})


@app.route("/reset_clear", methods=["POST"])
def reset_clear():
    with processing_lock:
        clear_event.clear()
        event_latch["clear"] = None
    log("[API] /reset_clear 호출됨")
    return jsonify({"status": "clear_reset"})


# --------------- SocketIO 이벤트 처리 ----------------

@socketio.on('connect')
def on_connect():
    log(f"[SocketIO] 클라이언트 연결됨: {request.sid}")
    emit('connected', {'msg': 'connected'})


@socketio.on('start_payment_ws')
def on_start_payment_ws(data):
    # data: {cart: {name: count}}
    log(f"[SocketIO] start_payment_ws 수신: {data}")
    cart = data.get('cart', {})
    global snack_queue, is_processing, current_idx, robot_state
    with processing_lock:
        if is_processing or robot_state != "IDLE":
            emit('error', {'message': 'Robot is busy'})
            return

        snack_queue.clear()
        is_processing = True
        current_idx = -1
        clear_event.clear()
        event_latch["clear"] = None

        for item, count in cart.items():
            signal = snack_map.get(item)
            if signal:
                snack_queue.extend([signal] * count)
    emit('start_payment_ack', {'status': 'waiting_for_coinpass'})


@socketio.on('send_snack_command')
def on_send_snack_command(data):
    # data: {"command": "coinpass"/"nextall"/"clear"/"stopping"}
    command = data.get('command')
    log(f"[SocketIO] send_snack_command 수신: {command}")
    global robot_socket

    if not robot_socket:
        emit('error', {'message': 'Robot socket not connected'})
        return

    try:
        robot_socket.sendall(f"{command}{MSG_DELIM}".encode())
        log(f"[SocketIO] 로봇에 명령 전송: {command}")
        emit('command_sent', {'command': command})
    except Exception as e:
        log(f"[SocketIO] 로봇 명령 전송 실패: {e}")
        emit('error', {'message': str(e)})


if __name__ == "__main__":
    log("[서버 시작] Flask 서버 시작")
    client_thread = threading.Thread(target=robot_socket_client, daemon=True, name="SocketClientThread")
    client_thread.start()

    socketio.run(app, host="0.0.0.0", port=5000, debug=False)
